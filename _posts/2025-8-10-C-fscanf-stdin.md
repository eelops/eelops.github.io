---
title: fscanf()面对不良文件输入的改进方法
author: eelops
date: 2025-08-10 21:30:00 +0800
categories: [C, Fieldnote]
tags: [file-input]
---

## 1. 问题背景：`%s` 的局限性

在使用 `fscanf` 解析具有特定结构（如 `key: value,`）的文本时，`%s` 格式说明符常常会因为其默认行为而出错。

`%s` 的规则是：**读取并存储一系列非空白字符（non-whitespace），直到遇到第一个空白字符（如空格、Tab、换行符）为止。**

这导致了一个问题：

```c
// 目标文件 data.txt 内容: "name: John, age: 25"
char name[50];
// 错误的尝试
fscanf(fp, "name: %s, age: %d", name, &age);
```

在这个例子中，`%s` 会读取 `"John,"` （连同逗号一起），因为逗号不是空白字符。这会导致后续对字面量逗号 `,` 的匹配失败，最终导致 `fscanf` 返回值不符合预期（返回1，而不是2），程序逻辑出错。

## 2. 解决方案：使用扫描集 `[^...]`

为了实现精确控制，应该使用 `fscanf` 提供的 **扫描集 (scanset)** 功能，特别是 `%[^...]`。

**语法**: `%[^characters]`

**功能**: 读取并存储一个字符串，该字符串包含 **除** `characters` 列表中指定字符以外的 **所有** 字符。当遇到列表中的任意一个字符时，读取立即停止。

### 修正代码

```c
// 目标文件 data.txt 内容: "name: John, age: 25"
    char name[50];
// 正确的实现
    fscanf(fp, "name: %[^,], age: %d", name, &age);
```

### 工作原理解析

1. `fscanf` 匹配字面量 `name:`。
2. 遇到 `%[^,]`，它开始读取后续字符，只要这个字符 **不是逗号 `,`**。
3. 它成功读取 `J`, `o`, `h`, `n`。
4. 当遇到 `,` 时，匹配了扫描集 `[^,]` 的停止条件，于是读取结束。`name` 变量被正确赋值为 `"John"`。
5. 此时，文件指针停留在 `,` 处。
6. `fscanf` 继续处理格式字符串的下一部分，即字面量 `,`，与文件中的 `,` 成功匹配。
7. 后续的 `age: %d` 也得以顺利解析。
8. 整个 `fscanf` 成功匹配了2个变量，返回值为2，符合 `if` 条件。

## 3. 扫描集 (Scanset) 总结

- **`%[...]`**: 只读取 **在** 集合内的字符。例如 `%[0-9]` 只读取数字。
- **`%[^...]`**: 读取 **不在** 集合内的字符。这是处理分隔符最常用的方式。

### 更多实用范例

- **安全读取一整行（包括空格）**:
```c
    char line[256];
    scanf("%[^]", line); // 读取直到换行符为止
```

- **读取直到分号或冒号**:
```c
    char data[100];
    fscanf(fp, "%[^;:]", data); // 读取直到遇到 ';' 或 ':'
```

## 4. 核心建议

当使用 `fscanf` 解析带有非空白分隔符的结构化文本时，**始终优先使用扫描集 `%[^...]` 而不是 `%s`**，以确保解析的精确性和健壮性。同时，永远不要忘记检查 `fscanf` 的返回值，确保其与你期望成功赋值的变量数量一致

